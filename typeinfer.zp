(module "typeinfer"
  (export
    (list "annotate-ast" annotate-ast)
    (list "infer-program" infer-program)
    (list "infer-expression" infer-expression))

  (find-binding (lambda (env bind)
    (if (list? bind)
      (let ((name (car bind)))
        (if (in? env name)
          (list:last (env name))
          :unknown))
      (if (in? env bind)
        (env bind)
        :unknown))))

  (annotate-ast (lambda () '()))

  (DEFAULT-ENV
    #{"+" (:integer :integer :integer)
      "-" (:integer :integer :integer)
      "*" (:integer :integer :integer)
      "/" (:integer :integer :integer)})

  (infer-program
    (lambda (prog . env)
      (reduce (lambda (env expr) (cadr (infer-expression expr env)))
              (if (null? env) DEFAULT-ENV (car env))
              prog)))

  (infer-expression (lambda (expr . env)
    (let* ((env (if (null? env) #{} (car env)))
           (return (lambda (x) (list x env))))
      (cond
        ((atom? expr) (return :atom))
        ((hash-map? expr) (return :hash-map))
        ((vector? expr) (return :vector))
        ((byte-vector? expr) (return :byte-vector))
        ((symbol? expr)
          (let ((sexpr (->string expr)))
            (if (in? env sexpr)
              (let ((res (infer-expression (env sexpr) env)))
                  (list (car res) (hash:set env sexpr (car res))))
              (return :unbound))))
        ((simple? expr) (return (string->symbol (++ ":" (typeof expr)))))
        (else (infer-special expr env))))))

  (infer-special (lambda (expr env)
    (case (car expr)
      ((quote)
        (list :list env))
      ((begin)
        (let ((sub (infer-program (cdr expr) env)))
          (list (car (infer-expression (list:last (cdr expr)) sub)) sub)))
      ((lambda)
        (let* ((sub (infer-expression (caddr expr) env))
               (type (++ (map (curry find-binding (cadr sub)) (cadr expr))
                         (car sub))))
          (list type env)))
      ((define)
        (infer-define expr env))
      (else
        (let ((name (->string (car expr))))
          (if (in? env name)
            (let ((type (env name)))
              (if (list? type)
                (let ((nenv (reduce (lambda (lenv tuple)
                                (let ((binds (car lenv))
                                      (env (cadr lenv)))
                                  (if (eq? 2 (length tuple))
                                    (let ((name (car tuple)))
                                      (if (not (symbol? name))
                                        (let ((b (infer-expression name)))
                                          (list (++ binds (car b)) env))
                                        (let ((name (->string name))
                                              (type (cadr tuple)))
                                          (if (and (in? env name) (not (eq? (env name) :unknown)))
                                            (if (or (eq? (env name) type) (eq? type :unknown))
                                              (list (++ binds (env name)) env)
                                              (list (++ binds type) (hash:set env name :ambiguous)))
                                            (list (++ binds type) (hash:set env name type))))))
                                    lenv)))
                               (list [] env)
                               (zip-with (lambda (x y) (list (list x y))) (cdr expr) type))))
                  (list (list:last type) (hash:update (cadr nenv)
                                                      name
                                                      (lambda (val)
                                                        (if (eq? (length val)
                                                                 (add1 (length (car nenv))))
                                                          (++ (car nenv) (list:last val))
                                                          val)))))
                (list :recurse env)))
            (list :unbound env)))))))

  (infer-define (lambda (expr env)
    (case (length expr)
      ((3)
        (if (list? (cadr expr))
          (let* ((sub (infer-expression (caddr expr) (hash:set env (->string (caadr expr)) :recurse)))
                 (type (++ (map (curry find-binding (cadr sub)) (cdadr expr))
                                (car sub))))
            (list type (hash:set env (->string (caadr expr)) type)))
          (let ((sub (infer-expression (caddr expr) env)))
            (list (car sub) (hash:set env (->string (cadr expr)) (car sub))))))
      ((4)
        (infer-define (filter (lambda (x) (not (string? x))) expr) env))))))
